"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMessageBarReflow", {
    enumerable: true,
    get: function() {
        return useMessageBarReflow;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _reactutilities = require("@fluentui/react-utilities");
function useMessageBarReflow(enabled = false) {
    const { targetDocument } = (0, _reactsharedcontexts.useFluent_unstable)();
    const prevInlineSizeRef = _react.useRef(-1);
    const messageBarRef = _react.useRef(null);
    const [reflowing, setReflowing] = _react.useState(false);
    // This layout effect 'sanity checks' what observers have done
    // since DOM has not been flushed when observers run
    (0, _reactutilities.useIsomorphicLayoutEffect)(()=>{
        if (!messageBarRef.current) {
            return;
        }
        setReflowing((prevReflowing)=>{
            if (!prevReflowing && messageBarRef.current && isReflowing(messageBarRef.current)) {
                return true;
            }
            return prevReflowing;
        });
    }, [
        reflowing
    ]);
    const handleResize = _react.useCallback(()=>{
        if (!messageBarRef.current) {
            return;
        }
        const inlineSize = messageBarRef.current.getBoundingClientRect().width;
        const scrollWidth = messageBarRef.current.scrollWidth;
        const expanding = prevInlineSizeRef.current < inlineSize;
        const overflowing = inlineSize < scrollWidth;
        setReflowing(!expanding || overflowing);
    }, []);
    const handleIntersection = _react.useCallback((entries)=>{
        if (entries[0].intersectionRatio < 1) {
            setReflowing(true);
        }
    }, []);
    const ref = _react.useMemo(()=>{
        let resizeObserver = null;
        let intersectionObserer = null;
        return (el)=>{
            if (!enabled || !el || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) {
                resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
                intersectionObserer === null || intersectionObserer === void 0 ? void 0 : intersectionObserer.disconnect();
                return;
            }
            messageBarRef.current = el;
            const win = targetDocument.defaultView;
            resizeObserver = new win.ResizeObserver(handleResize);
            intersectionObserer = new win.IntersectionObserver(handleIntersection, {
                threshold: 1
            });
            intersectionObserer.observe(el);
            resizeObserver.observe(el, {
                box: 'border-box'
            });
        };
    }, [
        handleResize,
        handleIntersection,
        enabled,
        targetDocument
    ]);
    return {
        ref,
        reflowing
    };
}
const isReflowing = (el)=>{
    return el.scrollWidth > el.offsetWidth || !isFullyInViewport(el);
};
const isFullyInViewport = (el)=>{
    const rect = el.getBoundingClientRect();
    const doc = el.ownerDocument;
    const win = doc.defaultView;
    if (!win) {
        return true;
    }
    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (win.innerHeight || doc.documentElement.clientHeight) && rect.right <= (win.innerWidth || doc.documentElement.clientWidth);
};
