import * as React from 'react';
import { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';
import { useIsomorphicLayoutEffect } from '@fluentui/react-utilities';
export function useMessageBarReflow(enabled = false) {
    const { targetDocument } = useFluent();
    const prevInlineSizeRef = React.useRef(-1);
    const messageBarRef = React.useRef(null);
    const [reflowing, setReflowing] = React.useState(false);
    // This layout effect 'sanity checks' what observers have done
    // since DOM has not been flushed when observers run
    useIsomorphicLayoutEffect(()=>{
        if (!messageBarRef.current) {
            return;
        }
        setReflowing((prevReflowing)=>{
            if (!prevReflowing && messageBarRef.current && isReflowing(messageBarRef.current)) {
                return true;
            }
            return prevReflowing;
        });
    }, [
        reflowing
    ]);
    const handleResize = React.useCallback(()=>{
        if (!messageBarRef.current) {
            return;
        }
        const inlineSize = messageBarRef.current.getBoundingClientRect().width;
        const scrollWidth = messageBarRef.current.scrollWidth;
        const expanding = prevInlineSizeRef.current < inlineSize;
        const overflowing = inlineSize < scrollWidth;
        setReflowing(!expanding || overflowing);
    }, []);
    const handleIntersection = React.useCallback((entries)=>{
        if (entries[0].intersectionRatio < 1) {
            setReflowing(true);
        }
    }, []);
    const ref = React.useMemo(()=>{
        let resizeObserver = null;
        let intersectionObserer = null;
        return (el)=>{
            if (!enabled || !el || !(targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.defaultView)) {
                resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
                intersectionObserer === null || intersectionObserer === void 0 ? void 0 : intersectionObserer.disconnect();
                return;
            }
            messageBarRef.current = el;
            const win = targetDocument.defaultView;
            resizeObserver = new win.ResizeObserver(handleResize);
            intersectionObserer = new win.IntersectionObserver(handleIntersection, {
                threshold: 1
            });
            intersectionObserer.observe(el);
            resizeObserver.observe(el, {
                box: 'border-box'
            });
        };
    }, [
        handleResize,
        handleIntersection,
        enabled,
        targetDocument
    ]);
    return {
        ref,
        reflowing
    };
}
const isReflowing = (el)=>{
    return el.scrollWidth > el.offsetWidth || !isFullyInViewport(el);
};
const isFullyInViewport = (el)=>{
    const rect = el.getBoundingClientRect();
    const doc = el.ownerDocument;
    const win = doc.defaultView;
    if (!win) {
        return true;
    }
    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (win.innerHeight || doc.documentElement.clientHeight) && rect.right <= (win.innerWidth || doc.documentElement.clientWidth);
};
